---
title: SQL-query optimaliseren die is gegenereerd in de updatewizard van de database
description: Leer hoe u het Adobe Campaign Classic-probleem kunt oplossen waarbij nieuwe kolommen moeten worden toegevoegd aan een bestaand schema.
solution: Campaign,Campaign Classic v7
product: Campaign,Campaign Classic v7
applies-to: Campaign Classic,Campaign,Campaign Classic v7
keywords: KCS, Campaign Classic V7, gegenereerde SQL-query optimaliseren, databaseupdatetovenaar
resolution: Resolution
internal-notes: It can be helpful when dealing with database update issues with big tables
bug: true
article-created-by: Tanay Sharma .
article-created-date: 6/19/2024 9:38:25 AM
article-published-by: Tanay Sharma .
article-published-date: 6/19/2024 9:49:12 AM
version-number: 5
article-number: KA-15785
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=533de7a7-1f2e-ef11-840b-6045bd0065b6
exl-id: 73e8701c-88e5-4b73-8c55-90eaee26d2ac
source-git-commit: edc744e70bdb98d4a15365eb7b9ea99fdb1feadc
workflow-type: tm+mt
source-wordcount: '390'
ht-degree: 1%

---

# SQL-query optimaliseren die is gegenereerd in de updatewizard van de database


Leer hoe u een veld met gehele getallen toevoegt aan een bestaand schema wanneer er al records bestaan en hoe u de SQL-query die door de toepassing wordt gegenereerd, optimaliseert om efficiënt te zijn voor Postgres SQL.

## Beschrijving {#description}


### <b>Omgeving</b>

- Adobe Campaign
- Adobe Campaign Classic


### Probleem/symptomen

In de meeste Adobe Campaign-builds, waaronder de Gold Standard 9032, kunnen meerdere problemen optreden wanneer u nieuwe kolommen toevoegt aan een bestaand schema.

Dit artikel heeft tot doel een specifiek probleem aan te pakken dat verband houdt met:

- Een geheel-getalveld toevoegen aan een bestaand schema wanneer er al records bestaan.
- Optimaliseer de SQL vraag die door de toepassing aan efficiënte wordt geproduceerd voor SQL Postgres.



## Resolutie {#resolution}


Wanneer u een kolom met gehele getallen toevoegt, wordt de SQL-instructie als volgt gegenereerd:


```
ALTER TABLE NmsRecipient ADD <column_name> SMALLINT;
UPDATE NmsRecipient SET <column_name> = 0;
ALTER TABLE NmsRecipient ALTER COLUMN <column_name> SET Default 0;
ALTER TABLE NmsRecipient ALTER COLUMN i<column_name> SET NOT NULL;
```


Het probleem is hier dat er vier bevelen in het gegevensbestand parallel worden uitgevoerd, die prestatieskwesties of een impasse kunnen veroorzaken.
De oplossing is deze vier bevelen in één te condenseren en nog de zelfde veranderingen aan te brengen zoals hieronder:


```
ALTER TABLE NmsRecipient ADD iFichierLiveDataCliqueurs SMALLINT NOT NULL SET Default 0 ;
```


Alle vereiste wijzigingen worden doorgevoerd, de kolom wordt toegevoegd, de standaardset wordt ingesteld `NOT NULL`en de waarde van bestaande records instellen op *0* vanwege de `NOT NULL` beperking.

<b>OPMERKING:</b>

Als er veelvoudige geheelkolommen zijn die moeten worden toegevoegd, voeg hen één voor één toe en stel de gegevensbestandtovenaar voor elke verandering in werking.

Dit zorgt voor een vloeiende werking, aangezien de instructie ook alle <b>bestaand </b>records naar *0*, wat tijd kan vergen afhankelijk van het aantal records.
<br>Oorzaak<br>
Dit kan gebeuren wanneer u bijvoorbeeld een bestaande tabel voor ontvangers of een andere tabel hebt die al meer dan een miljoen records bevat.

Als u nu één extra kolom aan die lijst moet toevoegen, die van gegevenstype Geheel getal is. In dat geval, voegt u die kolom in de schemadefinitie toe en wilt de veranderingen in het gegevensbestand begaan.

Tijdens het bijwerken van het gegevensbestand, ontmoet het gegevensbestand een impasse, of de vraag blokkeert andere verrichtingen.

Dit is voornamelijk het gevolg van het bijwerken van alle registers naar *0* gebaseerd op het SQL bevel dat door de gegevensbestandtovenaar wordt geproduceerd.
