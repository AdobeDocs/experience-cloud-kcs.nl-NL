---
title: Campaign Classic V7 - SQL-query optimaliseren die is gegenereerd in de updatewizard voor database
description: Beschrijving
solution: Campaign,Campaign Classic v7
product: Campaign,Campaign Classic v7
applies-to: Campaign Classic,Campaign,Campaign Classic v7
keywords: KCS
resolution: Resolution
internal-notes: It can be helpful when dealing with database update issues with big tables
bug: true
article-created-by: Marta Zator
article-created-date: 5/5/2022 10:16:35 AM
article-published-by: Marta Zator
article-published-date: 5/5/2022 10:18:58 AM
version-number: 2
article-number: KA-15785
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e810bb6a-5ccc-ec11-a7b5-6045bd00dbbc
exl-id: 73e8701c-88e5-4b73-8c55-90eaee26d2ac
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '366'
ht-degree: 1%

---

# Campaign Classic V7 - SQL-query optimaliseren die is gegenereerd in de updatewizard voor database

## Beschrijving


<b>Achtergrond en context:</b>
In de meeste Campagne bouwt met inbegrip van Gouden Standaard 9032 degenen, zouden wij veelvoudige kwesties kunnen ontmoeten wanneer het toevoegen van nieuwe kolommen aan een bestaand schema.

Dit artikel heeft tot doel een specifiek probleem aan te pakken dat verband houdt met:

- Een geheel-getalveld toevoegen aan een bestaand schema wanneer records al bestaan.
- Optimaliseer de SQL vraag die door de toepassing aan Efficiënt wordt geproduceerd voor SQL Postgres.


<b>Hoofdlettergebruik:</b> 
<br>We hebben een bestaande ontvangertabel of een andere tabel die al meer dan 1 miljoen records heeft.
<br>Er moet nu een extra kolom aan die tabel worden toegevoegd die een geheel getal van het gegevenstype heeft.
<br>Wij voegen die kolom in de schemadefinitie toe en wij willen de veranderingen in het gegevensbestand begaan.

<b>Uitdaging </b>:
<br>Wij ontmoeten en geven terwijl het bijwerken van het gegevensbestand en het Gegevensbestand een impasse of de vraagblokkeert andere verrichtingen tegen.
<br>Dit is hoofdzakelijk toe te schrijven aan het bijwerken van alle verslagen aan 0 die op het SQL bevel worden gebaseerd door de gegevensbestandtovenaar wordt geproduceerd.


<br> <br>

## Resolutie


Oplossing :

Bij het toevoegen van een kolom met gehele getallen wordt de SQL-instructie als volgt gegenereerd:

<b>ALTER TABLE NmsRecipient ADD column_name SMALLINT;
<br>NmsRecipient SET column_name = 0 UPDATE;
<br>ALTER TABLE NMSRecipient ALTER COLUMN column_name SET Default 0;
<br>ALTER TABLE NMSRecipient ALTER COLUMN icolumn_name SET NOT NULL;</b>

Het probleem hier is dat er 4 bevelen in het gegevensbestand parallel worden uitgevoerd die prestatieskwesties of een impasse kunnen veroorzaken.

De oplossing is deze 4 bevelen in één te condenseren en nog de zelfde veranderingen te doen zoals hieronder:

<b>ALTER TABLE NMSRecipient ADD FichierLiveDataCLIeurs SMALLINT NOT NULL SET Default 0;</b>

Het doet alle vereiste veranderingen, toevoegend de kolom, plaatsend het gebrek, plaatste NIET ONGELDIG, en ook plaatsend de waarde van bestaande verslagen aan 0 wegens de NIET ONGELDIGE beperking.



<b>OPMERKING :</b>

Als er veelvoudige geheelkolommen zijn die moeten worden toegevoegd, voeg hen één voor één toe en stel de gegevensbestandtovenaar voor elke verandering in werking.

Dit zorgt voor een vloeiende bewerking aangezien alle instructies worden bijgewerkt <b>bestaand </b>records naar 0 en afhankelijk van het nummer. van records die het kan duren.
