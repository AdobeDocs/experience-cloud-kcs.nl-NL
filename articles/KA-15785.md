---
title: "SQL-query die is gegenereerd in de updatewizard van de database optimaliseren"
description: "Leer hoe te om de kwestie van Adobe Campaign Classic op te lossen waar de nieuwe kolommen aan een bestaand schema moeten worden toegevoegd."
solution: Campaign,Campaign Classic v7
product: Campaign,Campaign Classic v7
applies-to: "Campaign Classic,Campaign,Campaign Classic v7"
keywords: "KCS, Campaign Classic V7, SQL geproduceerde vraag optimaliseren, de tovenaar van de gegevensbestandupdate"
resolution: Resolution
internal-notes: "It can be helpful when dealing with database update issues with big tables"
bug: true
article-created-by: Tanay Sharma .
article-created-date: "5/3/2024 12:44:18 PM"
article-published-by: Tanay Sharma .
article-published-date: "5/3/2024 12:49:40 PM"
version-number: 4
article-number: KA-15785
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=d6a7c3d4-4a09-ef11-9f8a-6045bd026dc7"
source-git-commit: 82cdb0cae5d8318fe8de839aff1ab26694f46437
workflow-type: tm+mt
source-wordcount: '357'
ht-degree: 0%

---

# SQL-query optimaliseren die is gegenereerd in de updatewizard van de database

## Beschrijving {#description}


<b>Omgeving</b>
Adobe Campaign Adobe Campaign Classic

<b>Probleem</b>
In de meeste Adobe Campaign-builds, waaronder de Gold Standard 9032, kunnen meerdere problemen optreden wanneer u nieuwe kolommen toevoegt aan een bestaand schema.

Dit artikel heeft tot doel een specifiek probleem aan te pakken dat verband houdt met:

- Een geheel-getalveld toevoegen aan een bestaand schema wanneer records al bestaan.
- Optimaliseer de SQL vraag die door de toepassing aan efficiënte wordt geproduceerd voor SQL Postgres.


<b>Oorzaak</b>
<br>Dit kan gebeuren wanneer u bijvoorbeeld een bestaande tabel voor ontvangers hebt of een andere tabel die al meer dan 1 miljoen records bevat.
<br>Als u nu één extra kolom aan die lijst moet toevoegen die van gegevenstype is `Integer`.
<br>Dan voegt u die kolom in de schemadefinitie toe en wilt de veranderingen in het gegevensbestand begaan.

<br>Tijdens het bijwerken van het gegevensbestand, ontmoet het gegevensbestand een impasse of de vraag blokkeert andere verrichtingen.
<br>Dit is voornamelijk het gevolg van het bijwerken van alle registers naar *0* gebaseerd op het SQL bevel dat door de gegevensbestandtovenaar wordt geproduceerd.<br>

## Resolutie {#resolution}


<b>Oplossing</b>
Wanneer u een kolom met gehele getallen toevoegt, wordt de SQL-instructie als volgt gegenereerd:


```
ALTER TABLE NmsRecipient ADD <column_name> SMALLINT;
UPDATE NmsRecipient SET <column_name> = 0;
ALTER TABLE NmsRecipient ALTER COLUMN <column_name> SET Default 0;
ALTER TABLE NmsRecipient ALTER COLUMN i<column_name> SET NOT NULL;
```


Het probleem is hier dat er 4 bevelen in het gegevensbestand parallel worden uitgevoerd die prestatieskwesties of een impasse kunnen veroorzaken.

De oplossing is deze 4 bevelen in één te condenseren en nog de zelfde veranderingen te doen zoals hieronder:


```
ALTER TABLE NmsRecipient ADD iFichierLiveDataCliqueurs SMALLINT NOT NULL SET Default 0 ;
```


Alle vereiste wijzigingen worden doorgevoerd, de kolom wordt toegevoegd, de standaardset wordt ingesteld `NOT NULL`en de waarde van bestaande records instellen op *0* vanwege de `NOT NULL` beperking.



<b>OPMERKING:</b>

Als er veelvoudige geheelkolommen zijn die moeten worden toegevoegd, voeg hen één voor één toe en stel de gegevensbestandtovenaar voor elke verandering in werking.

Dit zorgt voor een vloeiende bewerking aangezien alle instructies worden bijgewerkt <b>bestaand </b>records naar *0* en afhankelijk van het aantal records kan het tijd in beslag nemen .
