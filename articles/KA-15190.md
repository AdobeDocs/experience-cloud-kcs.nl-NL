---
title: "De stijgende Vraag neemt alle verslagen in plaats van slechts nieuwe op."
description: "Leer hoe u het Adobe Campaign Classic-probleem kunt verhelpen waarbij incrementele query's niet naar behoren werken."
solution: Campaign
product: Campaign
applies-to: "Campaign Classic"
keywords: "KCS, Incrementele query, Adobe Campaign Classic-uitgave"
resolution: Resolution
internal-notes: "Ticket = TK197178"
bug: true
article-created-by: Zita Rodricks
article-created-date: "6/17/2024 5:28:09 PM"
article-published-by: Zita Rodricks
article-published-date: "6/17/2024 6:19:05 PM"
version-number: 4
article-number: KA-15190
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=2158ecf4-ce2c-ef11-840a-002248084fbb"
source-git-commit: 2fbed231ed33419cb4e351f033bea4681513d136
workflow-type: tm+mt
source-wordcount: '398'
ht-degree: 1%

---

# Incrementele query haalt alle records op in plaats van alleen nieuwe records


Leer hoe u het Adobe Campaign Classic-probleem verhelpt, waarbij incrementele query&#39;s niet naar behoren werken.

## Beschrijving {#description}


### <b>Omgeving</b>

Campaign Classic



### <b>Probleem/symptomen</b>

Incrementele query&#39;s werken niet zoals verwacht. In plaats van slechts nieuwe verslagen sinds hun laatste looppas op te nemen, nemen zij alle verslagen elke keer als normale vraagactiviteit op.


## Resolutie {#resolution}


Dit probleem is opgelost in Adobe Campaign Classic 20.1.1 Release (build 9122 en hoger).

<b>Workarounds die gebruikers kunnen gebruiken:</b>

<b>Workaround 1</b>: Stop de opschoonworkflow en voer deze periodiek uit om de database en de vaste schijf op te schonen totdat de oplossing is genomen en beschikbaar. Het wordt niet aanbevolen als u geen geplande upgrade hebt.

<b>Workaround 2</b>: Stel dat de incrementele queryactiviteit wordt beïnvloed. Het werk rond het door het zelfde ding te doen dat de stijgende vraag door een blijvend schema te creëren doet om de inhoud van de geschiedenislijst te houden. Gebruik een combinatie vraag en werk gegevensactiviteiten bij om het gedrag na te bootsen. Dit zal voor alle werkschema&#39;s moeten worden gedaan die de stijgende vraag vereisen.

<b>Workaround 3</b>: Stel dat de incrementele queryactiviteit wordt beïnvloed. Hieromheen werken door een auditveld toe te voegen `tsCreated/tsLastModified` op het betrokken schema. Uw stijgende vraag zal dan in een normale vraagactiviteit met a worden omgezet waar clausule als `tscreated< GetDate()`.

<b>Workaround 4</b>:

1. Een nieuwe reeks maken `xtknewworkflowid` en initialiseer het aan iets ver weg van de huidige workflowId waaiers.
2. Wijzig de `xtkworkflow` schema om dit te gebruiken `pkSequence`.
3. Vraag de gebruiker om alle betrokken workflows te klonen en de originele werkstromen te verwijderen.
4. Als de gebruiker klaar is voor een upgrade, verwijdert u deze correctie door terug te keren naar `xtknewId` voor het maken van de workflow (om ongewenste verrassingen te voorkomen).

<b>Oorzaak</b>
De schuldige is de schoonmaakworkflow.

De incrementele queryworkflow werkt als volgt:

1. Behoudt een geschiedenislijst met resultaten van vorige herhalingen.
2. Hiermee worden alle rijen opgehaald uit de doelquery.
3. Hiermee worden alle rijen in de geschiedenistabel uitgefilterd
4. Hiermee voegt u de resterende resultaten toe aan de geschiedenistabel voor de volgende herhalingsfiltering.


De naam van deze werkbare historie heeft dus de volgende notatie:
`wkfhisto<workflowid>` `<activityName>_`

Nu, voor workflow-id&#39;s `<`  0 (voor gebruikers die `xtknewid` maakt negatieve sequenties mogelijk), zien we dat het eigenlijk is:

`wkfhisto<(uint)workflowid>``<activityName>_`

`Although this is okay for workflow execution.`

`So, for example, the incremental activity incremental1 of workflow ID=-1 will create a table wkfhisto4294967295_incremental1.`

`The thing which is missed is the CleanUp workflow.`

`Here, we have a code that tries to delete worktables of deleted workflows.`

`A dedicated code here lists all the wkfhisto tables, extracts the workflowId from their names (from the above convention), and deletes them all except the ones whose worklowIDs are found in the xtkworkflow table.`

`However, it misses the uint part.`

`So, it tries to look up a workflow with ID 4294967295 instead of casting this back to int. Since this workflow is not found, this table is deleted. Next time, when this workflow runs, the incremental query activity does not find an existing history table and creates it thinking of this as the first run ever.`
