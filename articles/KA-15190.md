---
title: Campaign Classic - Incrementele query haalt alle records op in plaats van alleen nieuwe records
description: Beschrijving
solution: Campaign
product: Campaign
applies-to: Campaign Classic
keywords: KCS
resolution: Resolution
internal-notes: Ticket = TK197178
bug: true
article-created-by: Marta Zator
article-created-date: 5/10/2022 9:47:14 AM
article-published-by: Marta Zator
article-published-date: 5/10/2022 9:51:21 AM
version-number: 2
article-number: KA-15190
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ad8bd527-46d0-ec11-a7b5-00224809c101
exl-id: f3dee0a7-8047-4949-9162-de95ba07fa7f
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '508'
ht-degree: 0%

---

# Campaign Classic - Incrementele query haalt alle records op in plaats van alleen nieuwe records

## Beschrijving


De klant heeft verscheidene stijgende vragen die niet zoals verwacht werken. In plaats van alleen nieuwe records op te halen sinds de laatste uitvoering, nemen ze elke keer alle records op - net als bij een normale query.


## Resolutie


De schuldige is de schoonmaakworkflow.

De incrementele queryworkflow werkt als volgt:

0. Een geschiedenistabel bijhouden met resultaten uit vorige herhalingen.
1. Vestig ALLE rijen van de doelvraag.
2. Alle rijen in de geschiedenistabel uitfilteren
3. Voeg de resterende resultaten toe aan de geschiedenislijst voor het volgende herhalings filtreren.

De naam van deze werkbare historie heeft dus de volgende notatie:
*wkfhistoworkflowid* activityName_

Nu, voor workflowIDs 0 (voor klanten waar `xtknewid` maakt negatieve sequenties mogelijk), zien we dat het eigenlijk is:

*wkfhisto(uint)workflowid* activityName_

Dit is echter prima voor het uitvoeren van de workflow.

De incrementele activiteit `incremental1` van workflow ID=-1 maakt een tabel `wkfhisto4294967295_incremental1`.

Wat gemist wordt, is de CleanUp-workflow.

Hier, hebben wij een code die probeert om werklijsten van geschrapte werkschema&#39;s te schrappen.

Een specifieke code hier maakt een lijst van alle wkfhisto \* lijsten, haalt workflowId uit hun namen (uit de bovengenoemde overeenkomst), en schrapt hen allen behalve degenen waarvan werklowIDs in de xtkworkflow lijst wordt gevonden.

Het gaat echter voorbij aan de `uint` deel.

Er wordt dus geprobeerd een workflow op te zoeken met ID 4294967295 in plaats van dit terug te geven naar int. Aangezien deze workflow niet wordt gevonden, wordt deze tabel verwijderd. De volgende keer, wanneer dit werkschema loopt, vindt de stijgende vraagactiviteit geen bestaande geschiedenislijst en leidt tot het denken van dit als eerste looppas ooit.

<b>Repareren:</b>

De oplossing voor dit probleem is beschikbaar in Adobe Campaign Classic 20.1.1 Release (build 9122 en hoger).

<b>Workarounds die klanten kunnen gebruiken:</b>

Workaround 1: Stop de opschoonworkflow en voer deze af en toe uit om de database en de vaste schijf op te schonen totdat de oplossing is opgehaald en beschikbaar. Niet aanbevolen als u geen geplande upgrade hebt.

Workaround 2: Veronderstel dat de stijgende activiteit van de Vraag en het wordt beïnvloed door het te doen het zelfde ding dat de stijgende Vraag door een permanent schema te creëren doet om de inhoud van de geschiedenislijst te houden doet. Gebruik een combinatie vraag en werk gegevensactiviteiten bij om het gedrag na te bootsen. Dit zal voor alle werkschema&#39;s moeten worden gedaan die de stijgende vraag vereisen.

Oplossing 3: veronderstel dat de stijgende activiteit van de Vraag wordt beïnvloed en het werk rond het door een controlegebied (tsCreated/tsLastModified) aan het schema in kwestie toe te voegen. Uw stijgende vraag zal dan in een normale vraagactiviteit met a worden omgezet waar clausule als `tscreated GetDate()`.

Workaround 4:

- Creeer een nieuwe opeenvolging xtknewworkflowid en initialiseer het aan iets dat ver weg van de huidige workflowId waaiers is.
- Wijzig het schema xtkworkflow om deze pkSequence te gebruiken
- Vraag de klant om alle betrokken workflows te klonen en de originele workflows te verwijderen.
- Zodra de klant klaar is voor een upgrade, verwijdert u deze correctie door terug te keren naar xtknownId voor het maken van de workflow (om ongewenste verrassingen te voorkomen).
