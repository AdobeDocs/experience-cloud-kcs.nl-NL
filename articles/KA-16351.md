---
title: ACC - Probleem bij laden van gegevens buiten verbinding
description: Beschrijving
solution: Campaign
product: Campaign
applies-to: Campaign Classic,Campaign
keywords: KCS - ACC - Probleem met laden van gegevens buiten
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Karan Khanna
article-created-date: 5/10/2022 2:11:09 PM
article-published-by: Karan Khanna
article-published-date: 5/10/2022 2:11:34 PM
version-number: 2
article-number: KA-16351
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=8f266a08-6bd0-ec11-a7b5-00224809c556
exl-id: 08e00479-988e-47cb-93d0-c718d06acc52
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '419'
ht-degree: 0%

---

# [ACC] - Probleem met laden van gegevens buiten join

## Beschrijving


Één van mijn klant ACC wordt geconfronteerd met een kwestie met SQL buitenverbindingen en wilde controleren of dit een verwacht gedrag is of is het een ACC insect.
 
 
Zoals per klant is er nms:leveringsgegevensschema uitgebreid door gsk:deliveryAnalytics in hun gegevensmodel. Ze hebben onder andere vier merkgerelateerde koppelingen toegevoegd aan het gegevensschema gsk:deliveryAnalyticsBrandMeta.
Koppelingsnamen zijn: metaBrandLink01, metaBrandLink02, metaBrandLink03, metaBrandLink04. Alles zijn buitenste verbindingen (externalJoin=&quot;true&quot;).
 
Deze koppelingen werken redelijk goed wanneer de operator @brand01-@brand04-kenmerken handmatig invult in eenmalige levering. Maar de kwestie komt voor wanneer de levering op een leveringsmalplaatje (bijvoorbeeld in terugkomende leveringsactiviteit) wordt gebaseerd. In dat geval worden alle @brand01-@brand04-velden leeg in nieuw uitgevoerde levering, hoewel ze in de leveringssjabloon zijn ingevuld. Het is geen invoerformulierprobleem omdat de klant dat al heeft gecontroleerd. Zij geloven het een SQL uitvoeringskwestie tijdens het laden van leveringsmalplaatje en het opnemen van zijn gegevens in een nieuwe levering is. Ze hebben dit in SQL-code waargenomen. Als zij type van verbinding in externalJoin= &quot;vals&quot;veranderen, dan kunnen zij zien dat de code juiste verbindingsverwijzingen bevat:   In SELECT-onderdeel: ... D30.sBrand, D30.iDeliveryAnalyticsBrandMetaId, ...   In FROM, deel van de code: VAN NmsDelivery D0 ... JOIN GskDeliveryAnalyticsBrandMeta D30 ON (D30.sBrand = D0.sBrand01) ...   Maar als zij externalJoin= &quot;waar&quot; gebruiken, dan is niets van dit een deel van SQL code die door terugkerende leveringsactiviteit wordt geproduceerd. Als gevolg hiervan worden merkvelden niet ingevuld bij nieuwe levering.
 
De klant wil weten waarom SQL de code buiten omvat sluit zich bij gegevens wanneer de nieuwe levering van het malplaatje wordt gecreeerd. Is het een AC insect of verwacht het AC gedrag.


## Resolutie


Volgens onze experts zou de externe deelname geen invloed hebben.

Wat u wilt doen in geval van kopiëren of terugkomen. Wilt u een nieuwe record maken in de tabelextensie of wilt u alleen naar dezelfde rij verwijzen?

In het geval van een kopie kunt u misschien proberen om het kenmerk af te spelen *integriteit.* Probeer het te gebruiken *owncopy*

In het tweede geval zou dat gewoon een kopie van de externe sleutel moeten zijn, zoals we elk kenmerk kopiëren. Kenmerk controleren *defOnDuplicate* voor uw externe sleutel.



Probeer vervolgens een kopie van uw bezorgings- of leveringssjabloon te maken vanuit de gebruikersinterface en controleer of het kenmerk of de externe sleutels zijn gekopieerd. Als het terugkerende levering werkt, zou ook moeten werken.
