---
title: Hoe te om SegmentNotFoundException te zuiveren wanneer de Uitgave in AEM 6.x wordt gemeld
description: Beschrijving
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Akash Kapoor
article-created-date: 4/3/2022 7:14:43 PM
article-published-by: Akash Kapoor
article-published-date: 4/3/2022 7:14:58 PM
version-number: 4
article-number: KA-19062
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=63dd174c-82b3-ec11-983f-000d3a5d09d6
exl-id: 0580f08b-a72c-45ec-817e-e850d2360e9d
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1214'
ht-degree: 0%

---

# Hoe te om SegmentNotFoundException te zuiveren wanneer de Uitgave in AEM 6.x wordt gemeld

## Beschrijving


<b>Hoe te om SegmentNotFoundException te zuiveren wanneer de Uitgave in AEM 6.x wordt gemeld</b>

A <b>SegmentNotFoundException</b> in het foutenlogboek betekent een segment niet meer aanwezig is hoewel iemand blijkbaar probeert om tot het nog toegang te hebben. Hiervoor bestaan er grosso modo drie verschillende oorzaken: het segment is verwijderd door handmatige interventie (bv. rm - rf /), het segment is verwijderd door de inzameling van de revisie of het segment kan niet worden gevonden wegens één of andere bug in de code.

In logboeken kan een uitzondering als de volgende voorkomen:

...

org.apache.jackrabbit.oak.segment.SegmentNotFoundException: Segment d2c720c4-c146-4ab1-ac37-542aad93c33f niet gevonden op org.apache.jackrabbit.segment.file.FileStore$8.call(FileStore.java:602) op org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:542) bij org.apache.cola.jakak.segment.SegmentCache.getSegment(SegmentCache.java:95) bij org.apache.jakobbit.oak.segment.file.FileStore.readSegment(FileStore.java):542) op org.apache.jackrabbit.oak.segment.SegmentId.getSegment(SegmentId.java:125) op org.apache.jackrabbit.oak.segment.Record.getSegment(Record.java:70) op org.apache.jackrabbit.segment.MapRecord.compare (MapRecord.java:424) op org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) op org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:391) op org.apache.jackrabbit.oak.segment SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:608) at org.apache.jackrabbit.oak.spi.commit.EditorDiff.childNodeChanged(EditorDiff.java:148) at org.apache.jackrabbit.oak.segment.MapRecord.childNodeChanged(MapRecord.java:442) op org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:490) op org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) op org.apache.jackrab bbit.oak.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:608) at org.apache.jackrabbit.oak.spi.commit.EditorDiff.process(EditorDiff.java:52) at org.apache.jackrabbit.plugins.index.AAA IndexUpdate.updateIndex(AsyncIndexUpdate.java:695) op org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.runWhenPermitted(AsyncIndexUpdate.java:543) op org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.Update run(AsyncIndexUpdate.java:402) op org.apache.sling.commons.planner.impl.QuartzJobExecurement.execute(QuartzJobExecurement.java:118) op org.quartz.core.JobRunShell.run(JobRunShell.java:202) bij java.util.concurrent.ThreadPoolExecurement.runWorker(ThreadPoolExecurement.java:1142) bij java.util.concurrent.ThreadPoolExecurement$Worker.run(ThreadPoolExecurement.java:617) bij java.lang.Thread.run(Thread .java:745)

...


## Resolutie


Er zijn twee benaderingen die we kunnen volgen om het probleem op te lossen en de inconsistenties in de opslagplaats te verwijderen die hieronder in de secties A en B worden beschreven.

<b>A. Terugkeren naar de laatst bekende goede revisie van de segmentopslag.</b>

In de eerste plaats moeten we de eik-run gebruiken, een runnable jar1 die alles bevat wat u nodig hebt voor een eenvoudige eik-installatie en het uitvoeren van bewerkingen met betrekking tot eikenhout.

De controle runtime-wijze van eak-looppas kan worden gebruikt om de laatste bekende goede revisie van een segmentopslag te bepalen.  Dat kan worden gebruikt om een corrupte segmentopslag aan zijn recentste goede revisie manueel terug te keren.

*Let op: Dit proces zal de gegevens in het systeem aan een vorig punt in tijd terugdraaien.  Als u wilt voorkomen dat wijzigingen in uw systeem verloren gaan, kunt u in plaats daarvan optie B hieronder proberen.*

De controle en het terugzetten uitvoeren:

1. Download een versie van een eak-run die overeenkomt met uw eak-kernversie van [https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run](https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run)
2. Om een corrupte segmentopslag terug te keren naar zijn recentste goede staatsverandering in de het werkfolder van CQ (die crx-quickstartfolder bevat) en steun alle dossiers in./crx-quickstart/repository/segmentstore/.
3. Voer de consistentiecontrole uit, java -Xmx6000m -jar oak-run-\*.jar check —bin=-1 /path/to/crx-quickstart/repository/segmentstore Dit zoekt achterwaarts door de revisies totdat er een consistente controle wordt gevonden: Kijk hieronder naar berichten: main INFO o.a.j.o.p.s.f.t.ConsistencyChecker - Nieuwste goede revisie gevonden fdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880
4. Herstel de repository naar deze revisie door te bewerken./crx-quickstart/repository/segmentstore/journal.log en alle regels verwijderen na de regel met de laatste goede revisie.
5. Alles verwijderen./crx-quickstart/repository/segmentstore/\*.bak-bestanden.
6. Opschonen van controlepunten uitvoeren om zwevende controlepunten te verwijderen met de volgende opdracht: java -Xmx6000m -jar oak-run-\*.jar checkpoints /path/to/crx-quickstart/repository/segmentstore rm-unreferenced
7. Tot slot comprimeer de repository: java -Xmx6000m -jar oak-run-\*.jar compact /path/to/crx-quickstart/repository/segmentstore/




*Er kunnen gevallen zijn wanneer de controle van de eikenlooppas niet de goede revisie kan vinden en wij &quot;ConsistencyChecker - Geen goede gevonden revisie&quot;terwijl het runnen van het controlebevel krijgen.*
<b>Hoe te om corruptie te bevestigen wanneer het ontmoeten van &quot;ConsistencyChecker - Geen goede die revisie&quot;bij consistentiecontrole wordt gevonden</b>


<b>B. Verwijder beschadigde knooppunten handmatig.</b>

In AEM, kunnen de montages TarMK zonder gevormde FileDatastore en situaties waar de corruptie in de binaire getallen is, u het volgende doen.

\*Let opn:\*De onderstaande procedure is bedoeld voor energiegebruikers.  Wanneer het schrappen van de corrupte knopen moet u ervoor zorgen zij geen systeemknopen (zoals /home, /jcr:system, enz.) zijn.  Of als het systeemknooppunten zijn, moet u ervoor zorgen dat u ze kunt herstellen.  Raadpleeg AEM Customer Care-team voor hulp bij de hier beschreven stappen als u het niet zeker weet.



1. Stop AEM.
2. Gebruik de de looppasconsole van het Eak en laad het childCount groovy manuscript om de corrupte knopen in de segmentopslag te identificeren:


Laad de oak-run console shell:

java -jar oak-run-\*.jar console crx-quickstart/repository/segmentstore

Voer de twee onderstaande opdrachten in de shell uit om het script te laden en uit te voeren:

:https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy laden

countNodes(session.workingNode)

Dit resulteert in de volgende uitvoer die het pad naar de beschadigde node(s) aangeeft:

21:21:42.029 hoofdFOUT o.a.j.o.p.segment.SegmentTracker - Segment niet gevonden: 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. De delta voor de aanmaakdatum is 3 ms.

waarschuwing kan knooppunt /content/dam/test.txt/jcr:content/renditions/original/jcr:content niet lezen

In sommige gevallen is de kwestie verbonden met binaire eigenschappen en het childCount groovy manuscript kan van geen bedorven knopen de plaats bepalen.  In deze gevallen kunt u de volgende opdracht gebruiken, die de eerste 1024 bytes leest voor elk binair getal dat tijdens het doorlopen wordt aangetroffen (Houd er rekening mee dat deze opdracht langzamer is en alleen moet worden gebruikt als de bovenstaande opdracht niet het verwachte resultaat oplevert):

countNodes(session.workingNode,true)

3. Verwijder alle geïdentificeerde corrupte knopen die in de output van het laatste bevel worden vermeld gebruikend rmNodes.groovy

Laad de console-shell die onder bevel werkt:

java -jar oak-run-\*.jar console crx-quickstart/repository/segmentstore

Het groepscript laden:

:load

https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy

Voer de opdracht rmNode uit om het beschadigde knooppunt te verwijderen. Vervang /path/to/corrupt/node door het pad naar het beschadigde knooppunt dat u moet verwijderen.

rmNode(sessie, &quot;/path/to/corrupt/node&quot;)

Waar het corrupte knooppuntweg de weg is die in stap 2 wordt verkregen, bijvoorbeeld: &quot;/content/dam/test.txt/jcr:content/renditions/original/jcr:content/&quot; Opmerking: Bij gebruik van eikenrun.jar versie 1.6.13 en hoger, set —read-write JVM parameter als er een fout optreedt zoals:

/ rmNode(session,&quot;/path/to/corrupt/node&quot;) Removing node /path/to/corrupt/node ERROR java.lang.UnsupportedOperationException:    Kan niet schrijven naar een alleen-lezen-winkel op org.apache.jackrabbit.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171) op org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318) op org.apache.write nmangrabbit.oak.segment.SegmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:111) op org.apache.nakeak.segment.SegmentNodeStore$Commit.init (SegmentNodeStore.java:581) op org.apache.nakebrobbit.oak.segment.SegmentNodeStore.merge (SegmentNodeStore.java:333) bij org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (Onbekende bron) bij groovysh_evaluate.rmNode (groovysh_evaluate:11)

4. Herhaal stap 3 voor alle knooppunten die in stap 2 worden gevonden.

Deze bovenstaande opdracht rmNode moet true retourneren voor het beschadigde pad, wat betekent dat het pad wordt verwijderd. Zorg ervoor dat deze gevonden drie beschadigde paden worden verwijderd door de opdracht rmNode voor die paden opnieuw uit te voeren. Vervolgens wordt de waarde false geretourneerd.

Als u nog steeds ziet dat dezelfde paden aanwezig zijn in de repository, gebruikt u de patchversie van de eikenrun jar, d.w.z. eak-run-1.2.18-NPR-17596

Wat doet de patchversie van Oak met Jar Do?

Deze versie van jar slaat onleesbare binaire getallen bij compilatie over die hen met 0 byte binaire getallen vervangen en de uitzondering en de weg aan syserr registreren. De zo gecomprimeerde opslagplaats zou dan een controle in werking stellen van het eikenaantal, het manuscript van de knooptelling moeten overgaan en u zou het ook moeten kunnen opnieuw compacteren gebruikend een niet gepatcheerde eiken-looppas.

5. Opschonen van controlepunten door hieronder controlepunten aan te bieden. Als er meer dan één controlepunt is, dan maak hen schoon:

nohup java -Xmx4096m -jar oak-run-1.2.18.jar checkpoints /app/AEM6/auteur/crx-quickstart/repository/segmentstore rm-allnohup.out &amp;

6. Een offlinecompressie uitvoeren.  Als u niet weet hoe u offline compressie kunt uitvoeren, raadpleegt u [hier](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).

7. Start de server op te wachten tot de indexering is voltooid.
